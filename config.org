* Server
** Start emacs server
 #+BEGIN_SRC emacs-lisp
 (require 'server)
(unless (server-running-p)
  (server-start))
 #+END_SRC

* Repos
  #+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t)
  #+END_SRC
* Settings
#+BEGIN_SRC emacs-lisp
(setq scroll-step 1)
(setq scroll-margin 10)
(setq scroll-conservatively 10000)
(setq select-enable-clipboard t)
(setq require-final-newline t)
(setq next-line-add-newlines nil)
(add-to-list 'write-file-functions 'delete-trailing-whitespace)
(fringe-mode '(8 . 0))
(setq-default indicate-empty-lines t)
(setq-default indicate-buffer-boundaries 'left)
(recentf-mode)
#+END_SRC
* Interface
** Basic settings
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
(tool-bar-mode -1)
(scroll-bar-mode -1)
(menu-bar-mode -1)
(fset 'yes-or-no-p 'y-or-n-p)
(global-set-key (kbd "<f5>") 'revert-buffer)
#+END_SRC
*** UTF-8
**** Set UTF-8 encoding
#+BEGIN_SRC emacs-lisp
  (setq locale-coding-system 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
#+END_SRC

* Org
** Install
  #+BEGIN_SRC emacs-lisp

  (use-package org
  :ensure t
  :pin org)

    (setenv "BROWSER" "chromium-browser")

        (use-package org-bullets
        :ensure t
        :config
        (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
  #+END_SRC
** Easy-to-add emacs-lisp template
Hitting tab after an "<el" in an org-mode file will create a template for elisp insertion.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'org-structure-template-alist
	       '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC"))
#+END_SRC

** Reload config file
#+BEGIN_SRC emacs-lisp
  (defun config-reload ()
    "Reloads ~/.emacs.d/config.org at runtime"
    (interactive)
    (org-babel-load-file (expand-file-name "~/.emacs.d/config.org")))
#+END_SRC
* try
#+BEGIN_SRC emacs-lisp
(use-package try
	:ensure t)
#+END_SRC

* Avy - navigate by searching for a letter on the screen and jumping to it
  See https://github.com/abo-abo/avy for more info
  #+BEGIN_SRC emacs-lisp
  (use-package avy
  :ensure t
  :bind ("M-s" . avy-goto-word-1)) ;; changed from char as per jcs
  #+END_SRC

* Autocomplete


  #+BEGIN_SRC emacs-lisp  :tangle no
     (use-package auto-complete
     :ensure t
     :init
     (progn
     (ac-config-default)
       (global-auto-complete-mode t)
      ))
  #+END_SRC
* Highligh current line
=hl-line= is awesome! It's not very awesome in the terminal version of emacs though, so we don't use that.
Besides, it's only used for programming.
#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode t)
#+END_SRC

* Window numbering
#+BEGIN_SRC emacs-lisp
(use-package window-numbering
  :ensure t
  :config
  (progn
    (setq window-numbering-auto-assign-0-to-minibuffer nil)
    (global-set-key (kbd "M-0") 'select-window-0)
    (global-set-key (kbd "M-1") 'select-window-1)
    (global-set-key (kbd "M-2") 'select-window-2)
    (global-set-key (kbd "M-3") 'select-window-3)
    (global-set-key (kbd "M-4") 'select-window-4)
    (global-set-key (kbd "M-5") 'select-window-5)
    (global-set-key (kbd "M-6") 'select-window-6)
    (global-set-key (kbd "M-7") 'select-window-7)
    (global-set-key (kbd "M-8") 'select-window-8)
    (global-set-key (kbd "M-9") 'select-window-9)
    (window-numbering-mode 1)))
#+END_SRC
* Helm
#+BEGIN_SRC emacs-lisp
(use-package helm
  :ensure t
  :config
  (require 'helm-config)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "C-x b") 'helm-mini)
  ;; (define-key help-map (kbd "<tab>") 'helm-execute-persistent-action)
  (global-set-key (kbd "M-i") 'helm-swoop)
  (global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
  (global-set-key (kbd "C-c h o") 'helm-occur)
  ;; (setq helm-locate-fuzzy-match t)
  ;; (setq helm-apropos-fuzzy-match t)
  ;; (setq helm-lisp-fuzzy-completion t)
  )

(use-package helm-swoop
  :ensure t
  :config
  (require 'helm-swoop))

(use-package helm-gtags
  :ensure t
  :config
  (setq
   helm-gtags-ignore-case t
   helm-gtags-auto-update t
   helm-gtags-use-input-at-cursor t
   helm-gtags-pulse-at-cursor t
   helm-gtags-prefix-key "\C-c g"
   helm-gtags-suggested-key-mapping t
   )
  ;; Enable helm-gtags-mode
  (add-hook 'lua-mode-hook 'helm-gtags-mode)
  (add-hook 'eshell-mode-hook 'helm-gtags-mode)
  (add-hook 'c-mode-hook 'helm-gtags-mode)
  (add-hook 'c++-mode-hook 'helm-gtags-mode)
  (add-hook 'asm-mode-hook 'helm-gtags-mode)

  (define-key helm-gtags-mode-map (kbd "C-c g a") 'helm-gtags-tags-in-this-function)
  (define-key helm-gtags-mode-map (kbd "C-j") 'helm-gtags-select)
  (define-key helm-gtags-mode-map (kbd "M-.") 'helm-gtags-dwim)
  (define-key helm-gtags-mode-map (kbd "M-,") 'helm-gtags-pop-stack)
  (define-key helm-gtags-mode-map (kbd "C-c <") 'helm-gtags-previous-history)
  (define-key helm-gtags-mode-map (kbd "C-c >") 'helm-gtags-next-history))


(use-package helm-themes
  :ensure t)
#+END_SRC
* Beacon
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :config
  (beacon-mode 1))
#+END_SRC
* Rainbow delimiters
#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :ensure t
  :init
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

* Theme
#+BEGIN_SRC emacs-lisp
  (use-package zerodark-theme
    :ensure t
    :init
      (load-theme 'zerodark t))
#+END_SRC
* Dired
** Dired quick sort
#+BEGIN_SRC emacs-lisp
(use-package dired-quick-sort
  :ensure t
  :config
  (dired-quick-sort-setup))
#+END_SRC
* Company
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :init
  (global-company-mode t))

(use-package company-quickhelp
  :ensure t)

(use-package company-c-headers
  :ensure t
  :init
  (require 'company-c-headers)
  (add-to-list 'company-backends 'company-c-headers)
  (add-to-list 'company-c-headers-path-system "/usr/include/c++/8.2.1/"))
#+END_SRC
* Flycheck
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :init
  (global-flycheck-mode t)
  (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
#+END_SRC
* Yasnippet
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :init
  (yas-global-mode 1))

(use-package yasnippet-snippets
  :ensure t
  :init
  (setq yas-snippet-dirs
	(progn
	  (dired  '("/home/napalm/.emacs.d/elpa/"))
	  (switch-to-buffer (other-buffer))
	  (set-buffer (other-buffer))
	  (dired-mark-files-regexp "yasnippet-snippets-[0-9]*\.[0-9]*")
	  (setq fname (dired-get-filename))
	  (kill-buffer (other-buffer))
	  (list fname))))
#+END_SRC
* Ggtags
#+BEGIN_SRC emacs-lisp
(use-package ggtags
  :ensure t
  :config
  (add-hook 'c-mode-common-hook
	    (lambda ()
	      (when (derived-mode-p 'c-mode 'c++-mode 'java-mode)
		(ggtags-mode 1)))))
#+END_SRC
* Neotree
#+BEGIN_SRC emacs-lisp
   (use-package neotree
     :ensure t
    :init
    ;; (setq neo-theme (if (display-graphic-p) 'icons 'arrow))
     )
   #+END_SRC

* Hungry delete
  #+BEGIN_SRC emacs-lisp
  (use-package hungry-delete
    :ensure t
    :config
    (global-hungry-delete-mode))
  #+END_SRC
* Hydra
   #+BEGIN_SRC emacs-lisp
     (use-package hydra
       :ensure t)

  ;;Hydra neotree
     (global-set-key (kbd "C-c n")
   		  (defhydra neotree
   		    ( :color blue)
   		    "neotree"
   		    ("t" neotree-toggle "neotree toggle")))


  ;; #   ;;Hydra cider
  ;; #   ;; (global-set-key (kbd "C-c c")
  ;; #   ;; 		(defhydra cider
  ;; #   ;; 		  ( :color blue)
  ;; #   ;; 		  "cider"
  ;; #   ;; 		  ("j" cider-jack-in "jack in")
  ;; #   ;; 		  ("c" cider-repl-clear-buffer "clear buffer")
  ;; #   ;; 		  ("e" cider-eval-buffer "eval buffer")))


     ;; Hydra for buffers
     (global-set-key
      (kbd "C-c b")
      (defhydra buffers
        ( :color blue)
        "buffer"
        ("b" helm-mini "buffer list")))


  ;; Hydra for recent files
     (global-set-key (kbd "C-c r")
   		  (defhydra hydra-recentf(:colr blue)
   		    "RecentFile"
   		    ("o" recentf-open-files "open")))
#+END_SRC
* Smartparens
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :init
    (require 'smartparens-config)
    (smartparens-global-mode t))
#+END_SRC
* Spaceline
#+BEGIN_SRC emacs-lisp
   (use-package spaceline
     :ensure t
     :config
     (require 'spaceline-config)
     (setq spaceline-buffer-encoding-abbrev-p nil)
     (setq spaceline-line-column-p nil)
     (setq spaceline-line-p nil)
     (setq powerline-default-separator (quote arrow))
     (spaceline-spacemacs-theme))
#+END_SRC

* My Function
#+BEGIN_SRC emacs-lisp
(defun daedreth/kill-inner-word ()
  "Kills the entire word your cursor is in. Equivalent to 'ciw' in vim."
  (interactive)
  (forward-char 1)
  (backward-word)
  (kill-word 1))
(global-set-key (kbd "C-c w k") 'daedreth/kill-inner-word)


(defun duplicate-line()
  (interactive)
  (move-beginning-of-line 1)
  (kill-line)
  (yank)
  (open-line 1)
  (next-line 1)
  (yank))
(global-set-key (kbd "C-c d l") 'duplicate-line)

(defun quick-copy-line ()
  "Copy the whole line that point is on and move to the beginning of the next line.
    Consecutive calls to this command append each line to the
    kill-ring."
  (interactive)
  (let ((beg (line-beginning-position 1))
	(end (line-beginning-position 2)))
    (if (eq last-command 'quick-copy-line)
	(kill-append (buffer-substring beg end) (< end beg))
      (kill-new (buffer-substring beg end))))
  (beginning-of-line 2))

(global-set-key (kbd "C-c q l") 'quick-copy-line)


(defun my--copy-word()
  (interactive)
  (forward-word)
  (setq beg (point))
  ;;  (message "Begin %d" beg)
  (call-interactively 'set-mark-command)
  (backward-word)
  (setq end (point))
  ;;(message "End %d" end)
  (kill-ring-save beg end))

(global-set-key (kbd "C-c q w") 'my--copy-word)

;;; Comment line or region

(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line if there's no active region."
  (interactive)
  (let (beg end)
    (if (region-active-p)
	(setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)
    (next-line)))

(global-set-key (kbd "C-c q r ") 'comment-or-uncomment-region-or-line)

(defun vi-open-line-above ()
  "Insert a newline above the current line and put point at beginning."
  (interactive)
  (unless (bolp)
    (beginning-of-line))
  (newline)
  (forward-line -1)
  (indent-according-to-mode))

(defun vi-open-line-below ()
  "Insert a newline below the current line and put point at beginning."
  (interactive)
  (unless (eolp)
    (end-of-line))
  (newline-and-indent))

(defun vi-open-line (&optional abovep)
  "Insert a newline below the current line and put point at beginning.
With a prefix argument, insert a newline above the current line."
  (interactive "P")
  (if abovep
      (vi-open-line-above)
    (vi-open-line-below)))

(global-set-key (kbd "C-S-o") 'vi-open-line-above)
(global-set-key (kbd "C-o") 'vi-open-line-below)

(add-hook 'c++-mode-hook 'display-line-numbers-mode )
;; (add-hook 'c++-mode-hook (setq tab-width 2))

(add-hook 'c-mode-hook 'display-line-numbers-mode )
;; (add-hook 'c-mode-hook (setq tab-width 2))


(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
#+END_SRC
* My Keybindings
#+BEGIN_SRC emacs-lisp
(global-set-key [f5] 'compile)
#+END_SRC
* Expand region
#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :bind ("C-q" . er/expand-region))
#+END_SRC
* Magit
#+BEGIN_SRC emacs-lisp
(use-package magit
    :ensure t
    :config
    (setq magit-push-always-verify nil)
    (setq git-commit-summary-max-length 50)
    :bind
    ("M-g" . magit-status))
#+END_SRC
* Projectile
Projectile is an awesome project manager, mostly because it recognizes directories
with a =.git= directory as projects and helps you manage them accordingly.

** Enable projectile globally
This makes sure that everything can be a project.
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :init
      (projectile-mode 1))
#+END_SRC
* QT pro mode
#+BEGIN_SRC emacs-lisp
  (use-package qt-pro-mode
    :ensure t
    :mode ("\\.pro\\'" "\\.pri\\'")
    :config
    (require 'qt-pro-mode)
    (add-to-list 'auto-mode-alist '()"\\.pr[io]$" . qt-pro-mode))
#+END_SRC
